<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby Nodejs Socket IoT | Scout Alarm Engineering]]></title>
  <link href="http://ScoutAlarm.github.io/blog/categories/ruby-nodejs-socket-iot/atom.xml" rel="self"/>
  <link href="http://ScoutAlarm.github.io/"/>
  <updated>2013-12-29T17:42:29-06:00</updated>
  <id>http://ScoutAlarm.github.io/</id>
  <author>
    <name><![CDATA[Scout Alarm]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[REST'ing on Binary]]></title>
    <link href="http://ScoutAlarm.github.io/blog/2013/12/29/resting-on-binary/"/>
    <updated>2013-12-29T14:41:51-06:00</updated>
    <id>http://ScoutAlarm.github.io/blog/2013/12/29/resting-on-binary</id>
    <content type="html"><![CDATA[<p>@ Scout we live at the intersection of web and hardware technologies. At first you may make the same mistake I did and assume that the hardware revolution can/ will just assimilate itself to standards established in the web 2.0 era. WRONG.</p>

<p>Disclaimer, This is my first encounter with hardware devices that communicate with the internet (IoT, internet of things).</p>

<p>A short background story, as we are developing the internal infrastructure for Scout, I began writing a web-service that would be a gateway for our devices to communicate with our ecosystem. Naively I created a RESTful api (btw if anyone is looking for a web-service DSL I seriously suggest looking at <a href="https://github.com/mattetti/Weasel-Diesel">https://github.com/mattetti/Weasel-Diesel</a>). I defined some resources and got as far as establishing all the important information we need to capture.</p>

<p>Tangent, data transfer is not a big consideration when developing for the web. For mobile, developers get a little bit more conscious but as long as you are sending only the data you need and using JSON, further optimization isn’t worth the effort (imho). The reason behind this is that technology has advancement so much, servers have gotten so powerful and cheap that protocol overhead and payload management isn&rsquo;t relevant like it used to be when the internet infrastructure was in its infancy.</p>

<p>Back to the story, With the following knowledge there was almost no reason for me to think about data transfer and how resources intensive protocols like HTTP are. Why would I, I have never seen a webserver choke when trying to process an http request.</p>

<p>Another Tangent, enter Internet of Things (iot), billions of small devices with sensors that are going to take over our lives. Most of these sensors are simple in implementation and are battery powered which gives them mobility to be anywhere and everywhere. Well here comes the fun part, all these battery powered devices are not going to come loaded with the latest and greatest in server technology. Imagine a scenario where someone loads RC car with a cinder block and expecting to run circles around your dog, not gonna happen. As such these devices have a microcontroller that is just powerful enough to do its task at the same time enabling the device to operate for as long as possible in remote locations on battery. Some may say this isn’t anything new, sensors have been in the field talking over RF forever and what I am talking about is nothing new. First, nothing about that statement is incorrect, 2) Fcuk RF, that so 1990&rsquo;s, I am talking about mesh protocols that are vastly superior to its RF counter part (the benefits are so great it deserves its own post).</p>

<p>Circling back, again, to the story, if we continued down the HTTP path our device would literally be maxing out their resource doing string manipulation and building http requests and parsing JSON responses. Imagine that, we are in the middle of a hardware revolution, and we cant even use strings&hellip; Scout also has the ability to operate over GSM and the more data that is sent over the wire the more the costs dig into our margins. So the incentives aligned to find a lower level protocol to communicate over.</p>

<p>The solution, TCP/IP + binary. Lets let that soak in a little. I haven’t touched binary in years and if there was ever a case where I needed to read a file through a stream, the binary piece is so abstracted that it&rsquo;s a black box for most young developers.</p>

<p>The hunt for a binary server began. Most production tested frameworks that I like/ have worked with don’t have great solution for handling TCP/IP. Sure ruby has a built in TCPSocketServer, but I don’t want to have to write a server framework from scratch&hellip;</p>

<p><code>ruby
s = TCPSocket.new 'localhost', 2000
while line = s.gets
  puts line
end
</code></p>

<p>After about three days of searching for a suitable ruby framework I decided to look at nodejs. I have never used it, but in my past life i dealt extensively in javascript client frameworks (backbone, angular, extjs, and dojo). Turns out, there is a great project called actionHero (<a href="https://github.com/evantahler/actionHero">https://github.com/evantahler/actionHero</a>). evantahler created an awesome solution that included the ability to define servers within a framework. And it just so happened that it included a json socket server out of the box&hellip; jackpot! (Finding this was a needle in a haystack situation). What was left was converting json input / output into binary opt codes + parameters. So I cloned the json scoket server, and redefined the parseRequest function and implemented a binaryActionRequestParser. The binaryActionRequestParser creates an object that acts in the same way the json socket server expects its data. This way i was able to throw the object at the server.processAction() and let it take care of the rest.</p>

<p>```ruby
var parseRequest = function(connection){
  server.log(&ldquo;parsing request&rdquo;, &lsquo;debug&rsquo;);
  parser = new api.utils.binaryActionRequestParse();
  parser.on(&ldquo;readable&rdquo;, function() {</p>

<pre><code>var e;
while (e = parser.read()) {
  server.log("action: "+JSON.stringify(e), 'debug');
  server.log("checking action against built in verbs", 'debug');
  connection.verbs(e.action, [], function(error, data){
    if(error == null){
      server.log("Found in built in verbs, data: "+JSON.stringify(data), 'debug');
      var message = {status: "OK", context: "response", data: data}
      server.sendMessage(connection, message);

    }else if(error === "verb not found or not allowed"){
      server.log("Not found in built in verbs", 'debug');
      try{ // check for and attempt to check single-use params
        server.log("trying custom request action: " + e.action, "debug");

        if(e.action != null){
          connection.params["action"] = e.action;
        }

        connection.params = e;

      }catch(e){
        connection.params.action = e.action;
      }

      connection.error = null;
      connection.response = {};

      server.processAction(connection);

    }else{
      server.sendMessage(connection, api.utils.binaryActionResponseSerialiser().unknown_call());
    }
  });
}
</code></pre>

<p>  });</p>

<p>  parser.write(connection.rawConnection.socketDataString);
}
```</p>

<p>ActionHero has proven to be an awesome tool for getting a binary server up and running, and it has been performing brilliantly. For parsing and producing binary data in node I used this repo (<a href="https://github.com/deoxxa/dissolve">https://github.com/deoxxa/dissolve</a>) and this repo (<a href="https://github.com/deoxxa/concentrate">https://github.com/deoxxa/concentrate</a>). Deoxxa, has great solution for working with binary data. It also gives you the ability to define your own patterns for consuming data if the built in functions aren&rsquo;t enough</p>

<p>Chaining calls:
<code>javascript
this.uint32be("uuid").uint16("opt_code").uint8bool("on_battery_power")
</code></p>

<p>Custom types:
```javascript
var uint8bool = function uint8bool(name) {
  return this.uint8be(name).tap(function() {</p>

<pre><code>this.vars[name] = (this.vars[name] == 1 ? true : false)
</code></pre>

<p>  });
};
```</p>

<p>Its incredible to think that with hardware taking such a big step forward in accessibility and implementation we (as developers) are forced to take steps back in communication protocols. I was a victim of trying to impose web standards in a field that is so vastly different. There is not this 1:1 correlation that I assumed/ wished there was. It&rsquo;s too early to tell, but I think the difference is for the best. We had to go back to basics and define a solution that works for the problem. It&rsquo;s like the saying goes; don&rsquo;t use an anvil when a hammer will do.</p>

<p>It is an exciting time and it will be interesting to see if more frameworks will be developed on languages such as ruby, node, python that will help usher in the new hardware revolution.</p>
]]></content>
  </entry>
  
</feed>
